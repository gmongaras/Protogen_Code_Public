from PIL import Image


# https://jspaint.app/#local:ac5222e2a28e8
# set canvas to 1024 x 512


image_input = "8.png"
# image_input = "inp.jpg"
output_path = "out.png"
outfile_path = "output.txt"
binoutfile_path = "output.bin"
size = (64, 32)
transpose = False
rotation_angle = 0#-22
down_shift = 0

# Color should be in RGB 565 format
# https://rgbcolorpicker.com/565
# color = 0x07E0 # Blue
color = 0x301f # Purple (6, 0, 31)
all_color = False

rainbow_left_to_right = True

# For some reason on the screen, they're supposed to be
# RGB565. However it seems they are actually
# RBG556. So same representation for each color,
# we just need to swap B and G?
swap_BG = True




import sys
import os

from PIL import Image
from PIL import ImageDraw
import struct

isSWAP = False
# isSWAP = True



import colorsys

def rgb888_to_rgb565(r, g, b):
    """Convert 8-bit RGB values to 16-bit RGB565."""
    r5 = (r >> 3) & 0x1F
    g6 = (g >> 2) & 0x3F
    b5 = (b >> 3) & 0x1F
    return (r5 << 11) | (g6 << 5) | b5

def rainbow_rgb565(t, max_):
    """
    Given t in [0, 63], return interpolated rainbow color in RGB565.
    Rainbow is generated by varying the hue in HSV space.
    """
    if not 0 <= t <= max_:
        raise ValueError("t must be in the range 0 to 63")

    # Map t to a hue value between 0 and 1
    hue = t / max_
    r, g, b = colorsys.hsv_to_rgb(hue, 1.0, 1.0)  # Saturation = 1, Value = 1

    # Convert to 0â€“255 range
    r, g, b = int(r * 255), int(g * 255), int(b * 255)

    # Convert to RGB565
    return rgb888_to_rgb565(r, g, b)




def shift_image_down(img, pixels_to_shift):
    """
    Shifts an image down by a specified number of pixels.

    Args:
        image_path: Path to the input image.
        pixels_to_shift: Number of pixels to shift the image down.
        output_path: Path to save the shifted image.
    """
    width, height = img.size

    # Create a new image with extra space at the top
    new_img = Image.new(img.mode, (width, height + pixels_to_shift), (0, 0, 0, 0) if img.mode == "RGBA" else (0, 0, 0))

    # Paste the original image onto the new image, shifted down
    new_img.paste(img, (0, pixels_to_shift))

    return new_img

def png2rgb565(img):
    if transpose:
        image_height = size[0]
        image_width = size[1]
    else:
        image_height = size[1]
        image_width = size[0]

    # Open output files
    try:
        outfile = open(outfile_path,"w")
    except:
        print ("Can't write the file %s" % outfile_path)
        sys.exit(0)
    try:
        binoutfile = open(binoutfile_path,"wb")
    except:
        print ("Can't write the binary file %s" % binoutfile_path)
        sys.exit(0)


    print ("uint16_t bitmap[HEIGHT][WIDTH2] = {", file=outfile)

    if transpose:
        pix = img.transpose(Image.FLIP_LEFT_RIGHT).load()
    else:
        pix = img.load()  #load pixel array
    for h in range(image_height):
        print ("\t", file=outfile, end = '{')
        for w in range(image_width):
            # if ((h * 16 + w) % 16 == 0):
            #     print (" ", file=outfile)
            #     print ("\t\t", file=outfile, end = '')

            if w < img.size[0]:
                # Either use a provided single color or
                # use the pixel color
                if rainbow_left_to_right:
                    if pix[w,h] == (0, 0, 0):
                        v = 0
                    else:
                        v = rainbow_rgb565(w, image_width)
                    R = 0x1F & v>>11 # 16->5
                    G = 0x3F & v>>5 # 16->6
                    B = 0x1F & v # 16->5
                else:
                    if all_color and pix[w,h] != (0, 0, 0):
                        R = 0x1F & color>>11 # 16->5
                        G = 0x3F & color>>5 # 16->6
                        B = 0x1F & color # 16->5
                    else:
                        R=0x1F & pix[w,h][0]>>3 # 8->5
                        G=0x3F & pix[w,h][1]>>2 # 8->6
                        B=0x1F & pix[w,h][2]>>3 # 8->5

                # Swap B and G
                if swap_BG:
                    rgb = (R<<11) | (B<<6) | G
                else:
                    rgb = (R<<11) | (G<<5) | B

                if (isSWAP == True):
                    swap_string_low = rgb >> 8
                    swap_string_high = (rgb & 0x00FF) << 8
                    swap_string = swap_string_low | swap_string_high
                    print ("0x%04x," %(swap_string), file=outfile, end = '')
                    binoutfile.write(struct.pack('H', swap_string))
                else:
                    print ("0x%04x," %(rgb), file=outfile, end = '')
                    binoutfile.write(struct.pack('H', rgb))
            else:
                rgb = 0
        #
        if h != image_height-1:
            print ("},\n", file=outfile, end = '')
        else:
            print ("}", file=outfile, end = '')
    print ("", file=outfile)
    print ("};", file=outfile)

    outfile.close()
    binoutfile.close()


# Load image
img = Image.open(image_input).convert("RGB")
# Resize
img = img.resize(size)
img.save("out.png")
# Rotate image
img = img.rotate(rotation_angle)
# Shift image down
img = shift_image_down(img, down_shift)





png2rgb565(img)




import numpy as np
from PIL import Image
import struct

# Define image size (64x32 as per the script)
width, height = 64, 32

# Read the binary output file
bin_file_path = "output.bin"
with open(bin_file_path, "rb") as f:
    data = f.read()

# Convert binary data to RGB565 values
pixels = np.frombuffer(data, dtype=np.uint16)

# Convert RGB565 to 24-bit RGB
def rgb565_to_rgb888(rgb565):
    r = ((rgb565 >> 11) & 0x1F) * 255 // 31
    g = ((rgb565 >> 5) & 0x3F) * 255 // 63
    b = (rgb565 & 0x1F) * 255 // 31
    return (r, g, b)

# Map all pixels to RGB888
rgb_pixels = np.array([rgb565_to_rgb888(p) for p in pixels], dtype=np.uint8)

# Reshape to image dimensions
rgb_pixels = rgb_pixels.reshape((height, width, 3))

# Save the reconstructed image
output_image_path = "reconstructed_output.png"
reconstructed_image = Image.fromarray(rgb_pixels)
reconstructed_image.save(output_image_path)